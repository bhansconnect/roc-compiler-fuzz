on:
  workflow_dispatch:
  push:
    branches: [main]

# Only allow one copy of this job to run at a time.
# This ensures no merge or cache conflicts.
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

permissions:
  contents: read
  actions: write

jobs:
  fuzz:
    strategy:
      matrix:
        fuzzer: [cli, tokenize]
      fail-fast: false
    runs-on: [ubuntu-24.04]
    steps:
      - name: checkout roc-compiler-fuzz
        uses: actions/checkout@v4
        with:
          path: roc-compiler-fuzz

      - name: checkout roc
        uses: actions/checkout@v4
        with:
          path: roc
          repository: roc-lang/roc

      - name: install zig
        uses: mlugg/setup-zig@v1
        with:
          version: 0.13.0

      - name: install afl++
        run: |
          sudo apt update
          sudo apt install -y afl++
          afl-fuzz --version

      - name: build roc fuzzer (base)
        env:
          AFL_CC_COMPILER: LTO
        run: |
          cd roc
          rm -rf .zig-cache zig-out $ZIG_LOCAL_CACHE_DIR

          zig build -Dfuzz -Dtarget=native-native -Dsystem-afl

          mv zig-out/bin/fuzz-${{ matrix.fuzzer }} ../fuzz-${{ matrix.fuzzer }}.afl

      # cmplog enables extracting comparision info to get better fuzz results.
      - name: build roc fuzzer (cmplog)
        env:
          AFL_LLVM_CMPLOG: 1
          AFL_CC_COMPILER: LTO
        run: |
          cd roc
          rm -rf .zig-cache zig-out $ZIG_LOCAL_CACHE_DIR

          zig build -Dfuzz -Dtarget=native-native -Dsystem-afl

          mv zig-out/bin/fuzz-${{ matrix.fuzzer }} ../fuzz-${{ matrix.fuzzer }}.cmplog

      - name: load cached corpus
        id: restore-cache-corpus
        uses: actions/cache/restore@v4
        with:
          key: fuzz-${{ matrix.fuzzer }}-corpus
          path: fuzz-${{ matrix.fuzzer }}-corpus
      
      # No matter what we reload examples from the repo.
      # They might get pruned, but we want to make sure we don't miss any new examples.
      - name: copy over initial corpus
        run: |
          mkdir -p fuzz-${{ matrix.fuzzer }}-corpus/
          cp roc/src/fuzz-corpus/${{ matrix.fuzzer }}/* fuzz-${{ matrix.fuzzer }}-corpus/

      - name: print corpus
        run: |
          ls fuzz-${{ matrix.fuzzer }}-corpus

      - name: configure system for fuzzing
        run: |
          sudo afl-system-config
      
      - name: run fuzz jobs
        env:
          AFL_TESTCACHE_SIZE: 500
          AFL_IGNORE_SEED_PROBLEMS: 1
          AFL_IMPORT_FIRST: 1
          AFL_FINAL_SYNC: 1
          # TODO: decide runtime and schedule for repetition.
          FUZZ_TIME: 60
        run: |
          # This is a rough attempt to follow best practices from: https://aflplus.plus/docs/fuzzing_in_depth/#c-using-multiple-cores
          afl-fuzz \
              -i fuzz-${{ matrix.fuzzer }}-corpus/ \
              -o fuzz-out/ \
              -V $FUZZ_TIME \
              -M main \
              -c ./fuzz-${{ matrix.fuzzer }}.cmplog \
              -l 2AT \
              -p explore \
              -- ./fuzz-${{ matrix.fuzzer }}.afl &
          afl-fuzz \
              -i fuzz-${{ matrix.fuzzer }}-corpus/ \
              -o fuzz-out/ \
              -V $FUZZ_TIME \
              -S s1 \
              -p fast \
              -c ./fuzz-${{ matrix.fuzzer }}.cmplog \
              -- ./fuzz-${{ matrix.fuzzer }}.afl &
          AFL_DISABLE_TRIM=1 afl-fuzz \
              -i fuzz-${{ matrix.fuzzer }}-corpus/ \
              -o fuzz-out/ \
              -V $FUZZ_TIME \
              -S s2 \
              -p explore \
              -- ./fuzz-${{ matrix.fuzzer }}.afl &
          afl-fuzz \
              -i fuzz-${{ matrix.fuzzer }}-corpus/ \
              -o fuzz-out/ \
              -V $FUZZ_TIME \
              -S s3 \
              -p exploit \
              -- ./fuzz-${{ matrix.fuzzer }}.afl &
          wait
      
      - name: fuzz stats
        run: |
          afl-whatsup -d fuzz-out/

      - name: minimize corpus
        env:
          # TODO: why is this needed?
          # Can we remove it?
          # afl-cmin seems to work correctly with this.
          AFL_SKIP_BIN_CHECK: 1
        run: |
          afl-cmin \
              -i fuzz-out/main/queue/ \
              -o fuzz-cmin/ \
              -T all \
              -- ./fuzz-${{ matrix.fuzzer }}.afl

          mkdir fuzz-tmin
          cd fuzz-cmin
          ls | parallel \
            afl-tmin \
                -i {} \
                -o ../fuzz-tmin/{} \
                -- ../fuzz-${{ matrix.fuzzer }}.afl
          cd ..

          rm -rf fuzz-${{ matrix.fuzzer }}-corpus
          mv fuzz-tmin fuzz-${{ matrix.fuzzer }}-corpus

      - name: print corpus
        run: |
          ls fuzz-${{ matrix.fuzzer }}-corpus

      # delete previous cache to enable overwritting it.
      - name: delete previous cache
        if: ${{ steps.restore-cache-corpus.outputs.cache-hit }}
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd roc-compiler-fuzz
          gh extension install actions/gh-actions-cache
          gh actions-cache delete "fuzz-${{ matrix.fuzzer }}-corpus" --confirm

      - name: save corpus
        id: save-cache-corpus
        uses: actions/cache/save@v4
        with:
          key: fuzz-${{ matrix.fuzzer }}-corpus
          path: fuzz-${{ matrix.fuzzer }}-corpus

      - name: minimize crashes
        run: |
          mv fuzz-out/main/hangs/ fuzz-hangs
          mv fuzz-out/main/crashes/ fuzz-crashes

          mkdir fuzz-crashes-tmin
          cd fuzz-crashes
          ls | parallel \
            afl-tmin \
                -i {} \
                -o ../fuzz-crashes-tmin/{} \
                -- ../fuzz-${{ matrix.fuzzer }}.afl
          cd ..

          rm -rf fuzz-crashes
          mv fuzz-crashes-tmin fuzz-crashes

      - name: list failures
        run: |
          ls fuzz-crashes
          ls fuzz-hangs

      # calculate list of crashes/hangs to report
      
      # update this repo with new failures and stats on passes
      # store inputs in base64 to make easy to copy commands
